import refrom datetime import datefrom os import walk, makedirsfrom os.path import exists, isfile, joinfrom shutil import move, copyfrom sys import exitstart = "samplefolder"justify_space = 100video_ext_list = ["mp4", "mkv", "avi", "wmv", "flv"]music_ext_list = ["mp3", "flac", "aac", "wav"]filter_list = ["axxo", "yify", "x264", "judas", "ac3"]ignore_list = ["sample"] """Checks if this one filename is that of a TV show.Returns (point at which the season was, (season, ep))or -1 and 0."""def interpret_seasonep(name_split):    for i in range(len(name_split)):        section = name_split[i]        # This just checks for the format sXXeXX        if(len(section) == 6 and section[0] == "s" and section[3] == "e"):            try:                season = int(section[1:3])                episode = int(section[4:6])                # Catching the rare circumstance that the season or episode                # is longer than 2 digits.                if (season > 99) or (episode > 99):                    return (-1, 0)                return (i, (season, episode))            except:                pass    # Only returns -1 once it has checked every bit of the filename    # for the previously stated seasonXXepisodeXX type format.    # Also checks for any other format where the season and episode    # are in a tight string together. E.g. 201 (season 2 episode 1).    return (-1, 0) def get_year(query):    return str(date.today().year)def comp(list1, list2):    strength = 0    for val1 in list1:        for val2 in list2:            if (val1.lower() in val2.lower()) or (val2.lower() in val1.lower()):                strength += 1    return strength"""Can return 4 cases: TVShow, Movie, Music and Unknown.TVShow: [name of the show, season, episode, extra information, extension]Movie: [name of the movie, year it was made, extension]Music:Unknown: Returns a string saying that it didn't work for this file."""def name_format(path):    # Not running on things like "sample.avi"        name = path.split("\\")[-1].lower()    if(comp([name], ignore_list) > 0):        return "ignored: " + path        one_up = path.split("\\")[-2].lower()    # Because not all of them will have a two up folder.    two_up = False    try:        two_up = path.split("\\")[-3].lower()    except:        pass        name_split = re.split("\W+", name)    # Filtering out stuff like x264 (but only on strings that are 3    # or more characters long, so we don't cut out things like "2".    name_split = [x.lower() for x in name_split if comp([x],                   filter_list) == False or len(x)<3]    ext = name_split[-1]        # Checking if the file is a video    if(ext in video_ext_list):        # Checking if the video is a TV show        tvresults = interpret_seasonep(name_split)        # interpret_seasonep returns -1 if it couldn't make it seasonep format.        if(tvresults[0] >= 0):            name = " ".join(name_split[0:tvresults[0]]).title()            season = tvresults[1][0]            episode = tvresults[1][1]            extra = " ".join(name_split[tvresults[0]+1:-1]).title()            return ("TVShow", [name, season, episode, extra, ext])        # Checking if the season info is held in an above folder.        elif "season" in one_up:            split_one_up = re.split("\W+", one_up)            bemes = 0            for i in range(len(split_one_up)):                if("season" in split_one_up[i]):                    break            try:                season = int(split_one_up[i+1])                bemes = i            except:                print "Folder name ending with season wtf?"                return "Unknown"                        if(two_up and two_up != start):                # E.g. Adventure time/season 2/episode 3                # Also makes sure that the two_up isn't just the root folder.                name = two_up.title()            elif(len(split_one_up) > 2 and "season" in split_one_up):                # E.g. Adventure time season 2/episode 3                name = " ".join(name_split[0:i]).title()            else:                                   # E.g. Adventure time season 3 episode 2                # Though this should be picked up by the first if statement.                name = " ".join(name_split[0:bemes+1]).title()            for i in range(len(name_split)):                if("episode" in name_split[i] or "ep" == name_split[i]):                    break            try:                episode = int(name_split[i+1])            except:                return "Unknown"            extra = " ".join(name_split[i+2:-1]).title()            return ("TVShow", [name, season, episode, extra, ext])        elif "season" in name and "episode" in name:            bemes = 0            for i in range(len(name_split)):                if("season" in name_split[i]):                    break                    bemes = i            for j in range(len(name_split)):                if("episode" in name_split[j]):                    break                        try:                season = int(name_split[i+1])                episode = int(name_split[j+1])            except:                print "File name ending with season/episode wtf?"                return "Unknown"            if(one_up != start):                name = one_up.title()            else:                name = " ".join(name_split[0:bemes+1]).title()            extra = " ".join(name_split[j+2:-1])            return ("TVShow", [name, season, episode, extra, ext])        # If not a TV show then it must be a movie        else:            year_point = -1            # Checking for a year already in the right format            for i in range(len(name_split)):                section = name_split[i]                # Checking if there is a year in the title                if(len(section) == 4):                    try:                        int(section)                        year = section                        year_point = i                    except:                         pass            name = " ".join(name_split[0:year_point]).title()            # Attempting to get the year that the movie was made in            if year_point == -1:                year = get_year(name)            return ("Movie", [name, year, ext])    # Checking if it is then music    elif(ext in music_ext_list):        # metadata is used mainly for this, don't sweat it.        return ("Music" + path)    else:        return "Other: " + path        #return "unknown. maybe dont move these ones but just log them"actions = [("make", join(start, "Movies")), ("make", join(start,"TV Shows")),            ("make", join(start,"Music"))]# First actual call to anything starts hereprint "Processing..."for root, dirs, files in walk(start, topdown=True):    for name in files:        path = join(root, name)        res = name_format(path)        if res[0] == "TVShow":            show_path = join(start, "TV Shows", res[1][0])            show_action = ("make", show_path)            if show_action not in actions:                actions.append(show_action)                        name = res[1][0]            seasonep = "s%02de%02d" % (res[1][1], res[1][2])            extra = ""            if res[1][3]:                extra = " - " + res[1][3]            ext = res[1][-1]                        new_name = "%s - %s%s.%s" % (name, seasonep, extra, ext)            season = "Season " + str(res[1][1])            season_path = join(show_path, season)            season_action = ("make", season_path)            if season_action not in actions:                actions.append(season_action)            new_path = join(season_path, new_name)            actions.append(("move", [path, new_path]))        elif res[0] == "Movie":            name = res[1][0]            year = res[1][1]            ext = res[1][2]            new_name = "%s (%s)" % (name, year)            folder_path = join(start, "Movies", new_name)            folder_action = ("make", folder_path)            if folder_action not in actions:                actions.append(folder_action)            new_name = new_name + "." + ext            new_path = join(folder_path, new_name)            actions.append(("move", [path, new_path]))# Can either make a folder or move something.# move syntax is ("move", [old, new]# make syntax is ("make", #folder path#)def print_actions():    print "\nActions to be performed:"    print "===================================================================="    for i in range(len(actions)):        if actions[i][0] == "make":            print "%03d Make: %s" % (i, actions[i][1])        elif actions[i][0] == "move":            print "%03d Move: %s --> %s" % (i, actions[i][1][0],                                            actions[i][1][1])        else:            print actions[i][1] + " is not a valid option."            actions.pop(i)def do_actions(actions):    for i in range(len(actions)):        if actions[i][0] == "make":            if not exists(actions[i][1]):                print "%03d Making %s" % (i, actions[i][1])                makedirs(actions[i][1])            else:                justified = actions[i][1].ljust(justify_space)                print "%03d The folder:    %s already exists." % (i, justified)        else:            old = actions[i][1][0]            new = actions[i][1][1]            old_good = isfile(old)            new_good = isfile(new)            if (old_good == True and new_good == False):                print "%03d Moving to %s" % (i, new)                copy(old, new)            elif(new_good == True):                justified = new.ljust(justify_space)                print "%03d The file  :    %s already exists." % (i,justified)            else:                justified = old.ljust(justify_space)                print "%03d The file  :    %s cannot be found." % (i,justified)print_actions()def getresponse():    response = raw_input("---------------------------------------------------\-----------------\nType (Y)es if you are happy to execute these \actions,\nor (N)o if you want to change something: ")[0].lower()    if response == "y":        do_actions(actions)        pass    elif response == "c":        print "Cancelling..."        exit()    elif response == "n":        to_remove = raw_input("\nEnter a number or list of numbers (separated \by spaces) corresponding\nto the actions to remove: ")        to_remove = sorted(to_remove.split(), reverse=True)        for number in to_remove:            try:                number = int(number)                if number < 0:                    print "Ignoring negative numbers"                else:                    print "Removed: %s" % actions[number][1]                    actions.pop(number)            except:                print "Only numbers separated by spaces please."                getresponse()                break        print_actions()        getresponse()    else:        print "Please enter y or n"        getresponse()getresponse()